INFO: 2021/04/06 18:40:22 basic_commands.go:18: v0.0.1-5254513 darwin/amd64  BuildDate: Wed, 17 Mar 2021 17:21:41 IST  Vendor: Red Hat

INFO: 2021/04/06 18:40:22 basic_commands.go:29: Cli tool to interact with CRDA Platform. This tool performs token Authentication and verbose Analyses of Dependency Stack. 
	
	Authenticated token can be used as Auth Token to interact with CRDA Platform.

Usage:
  crda [command]

Available Commands:
  analyse     Get detailed report of vulnerabilities.
  auth        Links uuid with Snyk token.
  completion  Generate completion script
  help        Help about any command
  version     Get binary version.

Flags:
  -d, --debug      Sets Log level to Debug.
  -h, --help       help for crda
  -c, --no-color   Toggle colors in output.

Use "crda [command] --help" for more information about a command.

INFO: 2021/04/06 18:40:22 basic_commands.go:59: Get detailed report of vulnerabilities. Supported ecosystems are Pypi (Python), Maven (Java), Npm (Node) and Golang (Go).
If stack has Vulnerabilities, command will exit with status code 2.

Usage:
  crda analyse [flags]

Flags:
  -h, --help      help for analyse
  -j, --json      Set output format to JSON.
  -v, --verbose   Detailed Analyses Report.

Global Flags:
  -d, --debug      Sets Log level to Debug.
  -c, --no-color   Toggle colors in output.

INFO: 2021/04/06 18:40:22 basic_commands.go:65: Command maps Snyk Token with UUID and Outputs 'crda_key' for further Authentication.
	
	To get "Snyk Token" Please click here: https://app.snyk.io/redhat/snyk-token

Usage:
  crda auth [flags]

Flags:
  -h, --help                help for auth
  -t, --snyk-token string   Authenticate with Snyk Token to unlock Verbose stack anaylses.

Global Flags:
  -d, --debug      Sets Log level to Debug.
  -c, --no-color   Toggle colors in output.

INFO: 2021/04/06 18:40:22 basic_commands.go:72: To load completions:

	Bash:
	
	$ source <(yourprogram completion bash)
	
	# To load completions for each session, execute once:
	Linux:
	  $ yourprogram completion bash > /etc/bash_completion.d/yourprogram
	MacOS:
	  $ yourprogram completion bash > /usr/local/etc/bash_completion.d/yourprogram
	
	Zsh:
	
	# If shell completion is not already enabled in your environment you will need
	# to enable it.  You can execute the following once:
	
	$ echo "autoload -U compinit; compinit" >> ~/.zshrc
	
	# To load completions for each session, execute once:
	$ yourprogram completion zsh > "${fpath[1]}/_yourprogram"
	
	# You will need to start a new shell for this setup to take effect.
	
	Fish:
	
	$ yourprogram completion fish | source
	
	# To load completions for each session, execute once:
	$ yourprogram completion fish > ~/.config/fish/completions/yourprogram.fish

Usage:
  crda completion [bash|zsh|fish|powershell]

Flags:
  -h, --help   help for completion

Global Flags:
  -d, --debug      Sets Log level to Debug.
  -c, --no-color   Toggle colors in output.

INFO: 2021/04/06 18:40:22 basic_commands.go:79: Command to output version of a binary.

Usage:
  crda version [flags]

Flags:
  -h, --help   help for version

Global Flags:
  -d, --debug      Sets Log level to Debug.
  -c, --no-color   Toggle colors in output.

INFO: 2021/04/06 18:40:22 basic_commands.go:86: Cli tool to interact with CRDA Platform. This tool performs token Authentication and verbose Analyses of Dependency Stack. 
	
	Authenticated token can be used as Auth Token to interact with CRDA Platform.

Usage:
  crda [command]

Available Commands:
  analyse     Get detailed report of vulnerabilities.
  auth        Links uuid with Snyk token.
  completion  Generate completion script
  help        Help about any command
  version     Get binary version.

Flags:
  -d, --debug      Sets Log level to Debug.
  -h, --help       help for crda
  -c, --no-color   Toggle colors in output.

Use "crda [command] --help" for more information about a command.

INFO: 2021/04/06 18:40:22 basic_commands.go:96: 
INFO: 2021/04/06 18:40:22 common.go:98: /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/manifests/package.json
INFO: 2021/04/06 18:40:22 common.go:99: /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/data/package.json
INFO: 2021/04/06 18:40:26 common.go:21: 
> core-js@2.6.12 postinstall /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/data/node_modules/core-js
> node -e "try{require('./postinstall')}catch(e){}"

added 101 packages from 118 contributors and audited 101 packages in 3.355s

3 packages are looking for funding
  run `npm fund` for details

found 32 vulnerabilities (16 low, 16 high)
  run `npm audit fix` to fix them, or `npm audit` for details

INFO: 2021/04/06 18:40:34 common.go:30: Analysing your Dependency Stack! Please wait...
Summary Report for Analyses:

[97;1mTotal Scanned Dependencies: [0m[97;1m4[0m
[97;1mTotal Scanned Transitive Dependencies: [0m[97;1m47[0m
[97;1mDirect Vulnerable Dependencies: [0m[97;1m2[0m
[97;1mTotal Vulnerabilities: [0m[97;1m7[0m
[97;1mCommonly Known Vulnerabilities: [0m[97;1m5[0m
[97;1mVulnerabilities Unique to Snyk: [0m[97;1m2[0m
[91;1mCritical Vulnerabilities: [0m[91;1m2[0m
[95;1mHigh Vulnerabilities: [0m[95;1m3[0m
[93;1mMedium Vulnerabilities: [0m[93;1m2[0m
[94;1mLow Vulnerabilities: [0m[94;1m0[0m

[97;1mFull Report: [0mhttps://recommender.api.openshift.io/api/v2/stack-report/2e92c0d809be4ed3b955dac441f6bd86

(Powered by Snyk)

tip: Use --verbose for detailed report.

INFO: 2021/04/06 18:40:35 common.go:98: /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/manifests/package.json
INFO: 2021/04/06 18:40:35 common.go:99: /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/data/package.json
INFO: 2021/04/06 18:40:38 common.go:21: 
> core-js@2.6.12 postinstall /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/data/node_modules/core-js
> node -e "try{require('./postinstall')}catch(e){}"

added 101 packages from 118 contributors and audited 101 packages in 3.132s

3 packages are looking for funding
  run `npm fund` for details

found 32 vulnerabilities (16 low, 16 high)
  run `npm audit fix` to fix them, or `npm audit` for details

INFO: 2021/04/06 18:40:47 common.go:38: {
	"total_scanned_dependencies": 4,
	"total_scanned_transitives": 47,
	"total_vulnerabilites": 7,
	"commonly_known_vulnerabilites": 5,
	"vulnerabilities_unique_to_synk": 2,
	"direct_vulnerable_dependencies": 2,
	"low_vulnerabilities": 0,
	"medium_vulnerabilities": 2,
	"high_vulnerabilities": 3,
	"critical_vulnerabilities": 2,
	"report_link": "https://recommender.api.openshift.io/api/v2/stack-report/41f33b041fc14b1a87a62ae06541962d"
}

INFO: 2021/04/06 18:40:47 common.go:40: 2
INFO: 2021/04/06 18:40:48 common.go:98: /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/manifests/vulns.json
INFO: 2021/04/06 18:40:48 common.go:99: /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/data/package.json
INFO: 2021/04/06 18:41:38 common.go:21: 
> core-js@2.6.12 postinstall /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/data/node_modules/core-js
> node -e "try{require('./postinstall')}catch(e){}"

added 100 packages from 117 contributors and audited 100 packages in 50.091s

3 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities


INFO: 2021/04/06 18:41:46 common.go:48: {
	"total_scanned_dependencies": 2,
	"total_scanned_transitives": 47,
	"total_vulnerabilites": 0,
	"commonly_known_vulnerabilites": 0,
	"vulnerabilities_unique_to_synk": 0,
	"direct_vulnerable_dependencies": 0,
	"low_vulnerabilities": 0,
	"medium_vulnerabilities": 0,
	"high_vulnerabilities": 0,
	"critical_vulnerabilities": 0,
	"report_link": "https://recommender.api.openshift.io/api/v2/stack-report/a63dc74ef8384b889314494df14d8bdb"
}

INFO: 2021/04/06 18:41:47 common.go:98: /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/manifests/package.json
INFO: 2021/04/06 18:41:47 common.go:99: /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/data/package.json
INFO: 2021/04/06 18:41:50 common.go:21: 
> core-js@2.6.12 postinstall /Users/sawood/go/src/github.com/fabric8-analytics/acceptance_tests/data/node_modules/core-js
> node -e "try{require('./postinstall')}catch(e){}"

added 101 packages from 118 contributors and audited 101 packages in 3.294s

3 packages are looking for funding
  run `npm fund` for details

found 32 vulnerabilities (16 low, 16 high)
  run `npm audit fix` to fix them, or `npm audit` for details

INFO: 2021/04/06 18:41:58 common.go:56: {
	"total_scanned_dependencies": 4,
	"total_scanned_transitives": 47,
	"total_vulnerabilites": 7,
	"commonly_known_vulnerabilites": 5,
	"vulnerabilities_unique_to_synk": 2,
	"direct_vulnerable_dependencies": 2,
	"low_vulnerabilities": 0,
	"medium_vulnerabilities": 2,
	"high_vulnerabilities": 3,
	"critical_vulnerabilities": 2,
	"report_link": "https://recommender.api.openshift.io/api/v2/stack-report/57e5748417d74d0492bd4e8ec10b820f"
}

INFO: 2021/04/06 18:41:58 common.go:58: 2
INFO: 2021/04/06 18:41:59 basic_commands.go:41: # bash completion for crda                                 -*- shell-script -*-

__crda_debug()
{
    if [[ -n ${BASH_COMP_DEBUG_FILE} ]]; then
        echo "$*" >> "${BASH_COMP_DEBUG_FILE}"
    fi
}

# Homebrew on Macs have version 1.3 of bash-completion which doesn't include
# _init_completion. This is a very minimal version of that function.
__crda_init_completion()
{
    COMPREPLY=()
    _get_comp_words_by_ref "$@" cur prev words cword
}

__crda_index_of_word()
{
    local w word=$1
    shift
    index=0
    for w in "$@"; do
        [[ $w = "$word" ]] && return
        index=$((index+1))
    done
    index=-1
}

__crda_contains_word()
{
    local w word=$1; shift
    for w in "$@"; do
        [[ $w = "$word" ]] && return
    done
    return 1
}

__crda_handle_go_custom_completion()
{
    __crda_debug "${FUNCNAME[0]}: cur is ${cur}, words[*] is ${words[*]}, #words[@] is ${#words[@]}"

    local shellCompDirectiveError=1
    local shellCompDirectiveNoSpace=2
    local shellCompDirectiveNoFileComp=4
    local shellCompDirectiveFilterFileExt=8
    local shellCompDirectiveFilterDirs=16

    local out requestComp lastParam lastChar comp directive args

    # Prepare the command to request completions for the program.
    # Calling ${words[0]} instead of directly crda allows to handle aliases
    args=("${words[@]:1}")
    requestComp="${words[0]} __completeNoDesc ${args[*]}"

    lastParam=${words[$((${#words[@]}-1))]}
    lastChar=${lastParam:$((${#lastParam}-1)):1}
    __crda_debug "${FUNCNAME[0]}: lastParam ${lastParam}, lastChar ${lastChar}"

    if [ -z "${cur}" ] && [ "${lastChar}" != "=" ]; then
        # If the last parameter is complete (there is a space following it)
        # We add an extra empty parameter so we can indicate this to the go method.
        __crda_debug "${FUNCNAME[0]}: Adding extra empty parameter"
        requestComp="${requestComp} \"\""
    fi

    __crda_debug "${FUNCNAME[0]}: calling ${requestComp}"
    # Use eval to handle any environment variables and such
    out=$(eval "${requestComp}" 2>/dev/null)

    # Extract the directive integer at the very end of the output following a colon (:)
    directive=${out##*:}
    # Remove the directive
    out=${out%:*}
    if [ "${directive}" = "${out}" ]; then
        # There is not directive specified
        directive=0
    fi
    __crda_debug "${FUNCNAME[0]}: the completion directive is: ${directive}"
    __crda_debug "${FUNCNAME[0]}: the completions are: ${out[*]}"

    if [ $((directive & shellCompDirectiveError)) -ne 0 ]; then
        # Error code.  No completion.
        __crda_debug "${FUNCNAME[0]}: received error from custom completion go code"
        return
    else
        if [ $((directive & shellCompDirectiveNoSpace)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __crda_debug "${FUNCNAME[0]}: activating no space"
                compopt -o nospace
            fi
        fi
        if [ $((directive & shellCompDirectiveNoFileComp)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __crda_debug "${FUNCNAME[0]}: activating no file completion"
                compopt +o default
            fi
        fi
    fi

    if [ $((directive & shellCompDirectiveFilterFileExt)) -ne 0 ]; then
        # File extension filtering
        local fullFilter filter filteringCmd
        # Do not use quotes around the $out variable or else newline
        # characters will be kept.
        for filter in ${out[*]}; do
            fullFilter+="$filter|"
        done

        filteringCmd="_filedir $fullFilter"
        __crda_debug "File filtering command: $filteringCmd"
        $filteringCmd
    elif [ $((directive & shellCompDirectiveFilterDirs)) -ne 0 ]; then
        # File completion for directories only
        local subDir
        # Use printf to strip any trailing newline
        subdir=$(printf "%s" "${out[0]}")
        if [ -n "$subdir" ]; then
            __crda_debug "Listing directories in $subdir"
            __crda_handle_subdirs_in_dir_flag "$subdir"
        else
            __crda_debug "Listing directories in ."
            _filedir -d
        fi
    else
        while IFS='' read -r comp; do
            COMPREPLY+=("$comp")
        done < <(compgen -W "${out[*]}" -- "$cur")
    fi
}

__crda_handle_reply()
{
    __crda_debug "${FUNCNAME[0]}"
    local comp
    case $cur in
        -*)
            if [[ $(type -t compopt) = "builtin" ]]; then
                compopt -o nospace
            fi
            local allflags
            if [ ${#must_have_one_flag[@]} -ne 0 ]; then
                allflags=("${must_have_one_flag[@]}")
            else
                allflags=("${flags[*]} ${two_word_flags[*]}")
            fi
            while IFS='' read -r comp; do
                COMPREPLY+=("$comp")
            done < <(compgen -W "${allflags[*]}" -- "$cur")
            if [[ $(type -t compopt) = "builtin" ]]; then
                [[ "${COMPREPLY[0]}" == *= ]] || compopt +o nospace
            fi

            # complete after --flag=abc
            if [[ $cur == *=* ]]; then
                if [[ $(type -t compopt) = "builtin" ]]; then
                    compopt +o nospace
                fi

                local index flag
                flag="${cur%=*}"
                __crda_index_of_word "${flag}" "${flags_with_completion[@]}"
                COMPREPLY=()
                if [[ ${index} -ge 0 ]]; then
                    PREFIX=""
                    cur="${cur#*=}"
                    ${flags_completion[${index}]}
                    if [ -n "${ZSH_VERSION}" ]; then
                        # zsh completion needs --flag= prefix
                        eval "COMPREPLY=( \"\${COMPREPLY[@]/#/${flag}=}\" )"
                    fi
                fi
            fi
            return 0;
            ;;
    esac

    # check if we are handling a flag with special work handling
    local index
    __crda_index_of_word "${prev}" "${flags_with_completion[@]}"
    if [[ ${index} -ge 0 ]]; then
        ${flags_completion[${index}]}
        return
    fi

    # we are parsing a flag and don't have a special handler, no completion
    if [[ ${cur} != "${words[cword]}" ]]; then
        return
    fi

    local completions
    completions=("${commands[@]}")
    if [[ ${#must_have_one_noun[@]} -ne 0 ]]; then
        completions+=("${must_have_one_noun[@]}")
    elif [[ -n "${has_completion_function}" ]]; then
        # if a go completion function is provided, defer to that function
        __crda_handle_go_custom_completion
    fi
    if [[ ${#must_have_one_flag[@]} -ne 0 ]]; then
        completions+=("${must_have_one_flag[@]}")
    fi
    while IFS='' read -r comp; do
        COMPREPLY+=("$comp")
    done < <(compgen -W "${completions[*]}" -- "$cur")

    if [[ ${#COMPREPLY[@]} -eq 0 && ${#noun_aliases[@]} -gt 0 && ${#must_have_one_noun[@]} -ne 0 ]]; then
        while IFS='' read -r comp; do
            COMPREPLY+=("$comp")
        done < <(compgen -W "${noun_aliases[*]}" -- "$cur")
    fi

    if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
		if declare -F __crda_custom_func >/dev/null; then
			# try command name qualified custom func
			__crda_custom_func
		else
			# otherwise fall back to unqualified for compatibility
			declare -F __custom_func >/dev/null && __custom_func
		fi
    fi

    # available in bash-completion >= 2, not always present on macOS
    if declare -F __ltrim_colon_completions >/dev/null; then
        __ltrim_colon_completions "$cur"
    fi

    # If there is only 1 completion and it is a flag with an = it will be completed
    # but we don't want a space after the =
    if [[ "${#COMPREPLY[@]}" -eq "1" ]] && [[ $(type -t compopt) = "builtin" ]] && [[ "${COMPREPLY[0]}" == --*= ]]; then
       compopt -o nospace
    fi
}

# The arguments should be in the form "ext1|ext2|extn"
__crda_handle_filename_extension_flag()
{
    local ext="$1"
    _filedir "@(${ext})"
}

__crda_handle_subdirs_in_dir_flag()
{
    local dir="$1"
    pushd "${dir}" >/dev/null 2>&1 && _filedir -d && popd >/dev/null 2>&1 || return
}

__crda_handle_flag()
{
    __crda_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"

    # if a command required a flag, and we found it, unset must_have_one_flag()
    local flagname=${words[c]}
    local flagvalue
    # if the word contained an =
    if [[ ${words[c]} == *"="* ]]; then
        flagvalue=${flagname#*=} # take in as flagvalue after the =
        flagname=${flagname%=*} # strip everything after the =
        flagname="${flagname}=" # but put the = back
    fi
    __crda_debug "${FUNCNAME[0]}: looking for ${flagname}"
    if __crda_contains_word "${flagname}" "${must_have_one_flag[@]}"; then
        must_have_one_flag=()
    fi

    # if you set a flag which only applies to this command, don't show subcommands
    if __crda_contains_word "${flagname}" "${local_nonpersistent_flags[@]}"; then
      commands=()
    fi

    # keep flag value with flagname as flaghash
    # flaghash variable is an associative array which is only supported in bash > 3.
    if [[ -z "${BASH_VERSION}" || "${BASH_VERSINFO[0]}" -gt 3 ]]; then
        if [ -n "${flagvalue}" ] ; then
            flaghash[${flagname}]=${flagvalue}
        elif [ -n "${words[ $((c+1)) ]}" ] ; then
            flaghash[${flagname}]=${words[ $((c+1)) ]}
        else
            flaghash[${flagname}]="true" # pad "true" for bool flag
        fi
    fi

    # skip the argument to a two word flag
    if [[ ${words[c]} != *"="* ]] && __crda_contains_word "${words[c]}" "${two_word_flags[@]}"; then
			  __crda_debug "${FUNCNAME[0]}: found a flag ${words[c]}, skip the next argument"
        c=$((c+1))
        # if we are looking for a flags value, don't show commands
        if [[ $c -eq $cword ]]; then
            commands=()
        fi
    fi

    c=$((c+1))

}

__crda_handle_noun()
{
    __crda_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"

    if __crda_contains_word "${words[c]}" "${must_have_one_noun[@]}"; then
        must_have_one_noun=()
    elif __crda_contains_word "${words[c]}" "${noun_aliases[@]}"; then
        must_have_one_noun=()
    fi

    nouns+=("${words[c]}")
    c=$((c+1))
}

__crda_handle_command()
{
    __crda_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"

    local next_command
    if [[ -n ${last_command} ]]; then
        next_command="_${last_command}_${words[c]//:/__}"
    else
        if [[ $c -eq 0 ]]; then
            next_command="_crda_root_command"
        else
            next_command="_${words[c]//:/__}"
        fi
    fi
    c=$((c+1))
    __crda_debug "${FUNCNAME[0]}: looking for ${next_command}"
    declare -F "$next_command" >/dev/null && $next_command
}

__crda_handle_word()
{
    if [[ $c -ge $cword ]]; then
        __crda_handle_reply
        return
    fi
    __crda_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"
    if [[ "${words[c]}" == -* ]]; then
        __crda_handle_flag
    elif __crda_contains_word "${words[c]}" "${commands[@]}"; then
        __crda_handle_command
    elif [[ $c -eq 0 ]]; then
        __crda_handle_command
    elif __crda_contains_word "${words[c]}" "${command_aliases[@]}"; then
        # aliashash variable is an associative array which is only supported in bash > 3.
        if [[ -z "${BASH_VERSION}" || "${BASH_VERSINFO[0]}" -gt 3 ]]; then
            words[c]=${aliashash[${words[c]}]}
            __crda_handle_command
        else
            __crda_handle_noun
        fi
    else
        __crda_handle_noun
    fi
    __crda_handle_word
}

_crda_analyse()
{
    last_command="crda_analyse"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--json")
    flags+=("-j")
    local_nonpersistent_flags+=("--json")
    local_nonpersistent_flags+=("-j")
    flags+=("--verbose")
    flags+=("-v")
    local_nonpersistent_flags+=("--verbose")
    local_nonpersistent_flags+=("-v")
    flags+=("--debug")
    flags+=("-d")
    flags+=("--no-color")
    flags+=("-c")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_crda_auth()
{
    last_command="crda_auth"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--snyk-token=")
    two_word_flags+=("--snyk-token")
    two_word_flags+=("-t")
    local_nonpersistent_flags+=("--snyk-token")
    local_nonpersistent_flags+=("--snyk-token=")
    local_nonpersistent_flags+=("-t")
    flags+=("--debug")
    flags+=("-d")
    flags+=("--no-color")
    flags+=("-c")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_crda_completion()
{
    last_command="crda_completion"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--help")
    flags+=("-h")
    local_nonpersistent_flags+=("--help")
    local_nonpersistent_flags+=("-h")
    flags+=("--debug")
    flags+=("-d")
    flags+=("--no-color")
    flags+=("-c")

    must_have_one_flag=()
    must_have_one_noun=()
    must_have_one_noun+=("bash")
    must_have_one_noun+=("fish")
    must_have_one_noun+=("powershell")
    must_have_one_noun+=("zsh")
    noun_aliases=()
}

_crda_help()
{
    last_command="crda_help"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--debug")
    flags+=("-d")
    flags+=("--no-color")
    flags+=("-c")

    must_have_one_flag=()
    must_have_one_noun=()
    has_completion_function=1
    noun_aliases=()
}

_crda_version()
{
    last_command="crda_version"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--debug")
    flags+=("-d")
    flags+=("--no-color")
    flags+=("-c")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_crda_root_command()
{
    last_command="crda"

    command_aliases=()

    commands=()
    commands+=("analyse")
    commands+=("auth")
    commands+=("completion")
    commands+=("help")
    commands+=("version")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--debug")
    flags+=("-d")
    flags+=("--no-color")
    flags+=("-c")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

__start_crda()
{
    local cur prev words cword
    declare -A flaghash 2>/dev/null || :
    declare -A aliashash 2>/dev/null || :
    if declare -F _init_completion >/dev/null 2>&1; then
        _init_completion -s || return
    else
        __crda_init_completion -n "=" || return
    fi

    local c=0
    local flags=()
    local two_word_flags=()
    local local_nonpersistent_flags=()
    local flags_with_completion=()
    local flags_completion=()
    local commands=("crda")
    local must_have_one_flag=()
    local must_have_one_noun=()
    local has_completion_function
    local last_command
    local nouns=()

    __crda_handle_word
}

if [[ $(type -t compopt) = "builtin" ]]; then
    complete -o default -F __start_crda crda
else
    complete -o default -o nospace -F __start_crda crda
fi

# ex: ts=4 sw=4 et filetype=sh

(type -t compopt) = "builtin" ]]; then
    complete -o default -F __start_crda crda
else
    complete -o default -o nospace -F __start_crda crda
fi

# ex: ts=4 sw=4 et filetype=sh

